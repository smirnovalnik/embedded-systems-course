/**
  ******************************************************************************
  * \file    main.c
  * \author  Александр Смирнов
  * \version 1.1.0
  * \date    1.08.2017
  * \brief   Пример проекта для выполнения лабораторной работы №2.
  *          Программа подсчитывает количество единиц в двоичном представлении
  *          числа. Ввода числа и вывод результата производится в эмуляторе
  *          терминала на персональном компьютере.
  ******************************************************************************
  */

/* Подключение заголовочного файла с макроопределениями
   регистров специальных функций микроконтроллера К1986ВЕ92QI(MDR32F9Q2I) */
#include <MDR32Fx.h>
/* Подключение заголовочного файла с конфигурацией библиотеки
   Standard Peripheral Library (SPL) для микроконтроллера К1986ВЕ92QI(MDR32F9Q2I) */
#include <MDR32F9Qx_config.h>
/* Подключение функций управления тактированием из библиотеки SPL */
#include <MDR32F9Qx_rst_clk.h>

/* Подключение функций стандартного ввода/вывода (printf и scanf)
   из стандартной библиотеки C */
#include <stdio.h>

/* На отладочной плате модуль UART микроконтроллера подключен
   к преобразователю UART - RS-232.
   Персональный компьютер подключается к разъему RS-232 отладочной
   платы через преобразователь RS-232 - USB.
   На персональном компьютере в программе терминале используется
   последовательный порт (COM порт) с параметрами:
   115200 8N1 (скорость передачи 115200 бод,
   8 бит данных, без контроля четности и 1 стоп бит).
   В данном проекте ввод и вывод символов производится
   с помощью стандартной библиотеки ввода/вывода (функции printf и scanf).
   Стандартная библиотека ввода/вывода на микроконтроллере не знает куда
   отправлять символы и откуда их принимать.
   Поэтому для использования стандартной библиотеки ввода/вывода
   переопределены функции stdin_getchar и stdout_putchar
   для приема и передачи символов по UART (файлы uart_io.h, uart_io.c).
*/
#include "uart_io.h"


/* Настройка тактового сигнала центрального процессора (ЦП) микроконтроллера.
   После запуска микроконтроллер начинает тактироваться от внутреннего
   высокочастотного RC генератора (HSI, 8 МГц). Стабильности частоты данного
   генератора не достаточно для согласования скоростей передачи UART
   микроконтроллера и COM порта персонального компьютера.
   На отладочной плате установлен внешний кварцевый резонатор (HSE, 8 МГц),
   который обладает достаточной стабильностью для согласования UART и COM порта.
   Функция sys_clk_init включает умножитель частоты (ФАПЧ) с опорным сигналом
   HSE. Суммарный коэффициент умножения задается коэффициентом предделителя HSE,
   коэффициентом умножения ФАПЧ и делителем тактового сигнала ЦП.
   Частота ЦП: fhse * (1/div_hse) * pll_mul * (1/cpu_div) =
   8 МГц * (1/1) * 10 * (1/1) = 80 МГц
   Для более подробной информации смотри структурную схему формирования тактовой
   частоты в спецификации К1986ВЕ92QI(MDR32F9Q2I).
   */
void sys_clk_init(void)
{
    /* Разрешение работы внешнего высокочастотного резонатора (HSE) */
    RST_CLK_HSEconfig(RST_CLK_HSE_ON);

    /* Проверка готовности HSE */
    if (RST_CLK_HSEstatus() == SUCCESS)
    {
        /* Выбор резонатора HSE для тактирования ФАПЧ ЦП (PLL_CPU) и
           установка множителя частоты ФАПЧ на 10 */
        RST_CLK_CPU_PLLconfig(RST_CLK_CPU_PLLsrcHSEdiv1, RST_CLK_CPU_PLLmul10);
        /* Включение ФАПЧ */
        RST_CLK_CPU_PLLcmd(ENABLE);
        /* Проверка завершения инициализации ФАПЧ */
        if (RST_CLK_CPU_PLLstatus() == SUCCESS)
        {
            /* Установка предделителя тактового сигнала ЦП в 1 */
            RST_CLK_CPUclkPrescaler(RST_CLK_CPUclkDIV1);
            /* Подключение выхода ФАПЧ к CPU_C3*/
            RST_CLK_CPU_PLLuse(ENABLE);
            /* Выбор тактового сигнала CPU_C3 для тактирования ЦП */
            RST_CLK_CPUclkSelection(RST_CLK_CPUclkCPU_C3);
        }
    }
    else
    {
        /* Сюда программа не должна никогда попасть, а если попала, то значит
           аппаратные проблемы с внешним кварцевым резонатором */
        for(;;);
    }

    /* Обновление глобальной переменной SystemCoreClock, содержащей значение
       частоты центрального процессора */
    SystemCoreClockUpdate();
}

/*----------------------Ваше решение начинается здесь-------------------------*/
/* Функция подсчета количества единиц в двоичном представлении числа */
unsigned char bitcount(unsigned int n)
{
    unsigned char cnt;

    for (cnt = 0; n != 0; n >>= 1)
        if (n & 1)
            cnt++;

    return cnt;
}
/*----------------------Ваше решение заканчивается здесь----------------------*/

/* Функция main. Точка входа в программу */
int main(void)
{
    /* Вызов функции настройки частоты тактирования ЦП */
    sys_clk_init();

    /* Вызов функции инициализации UART для стандартного потока */
    uart_io_init();

/*----------------------Ваше решение начинается здесь-------------------------*/
    /* Объявление переменной, в которую будет сохраняться веденное число */
    unsigned int n;

    /* Печать строки приветствия в стандартный поток */
    printf("Counting ones in binary notation of number\n");

    /* Бесконечный цикл */
    for (;;)
    {
        /* Печать строки в стандартный поток */
        printf("Input number: ");

        /* Функция scanf - аналог функции printf,
           осуществляющая форматированный ввод.
           В данном примере ожидается ввод беззнакового целого числа и проверка
           количества преобразованных значений.
           Результат помещается в переменную n.
           Переменная n (как и все аргументы функции) передается в scanf
           через указатель для того, чтобы scanf смогла записать в n результат ввода.
           Строка "%u" называется строкой форматирования и указывает,
           что scanf будет ожидать ввода беззнакового (unsigned) целого числа.
           Функция возвращает количество успешно прочитанных значений.
           В данном случае делается попытка прочитать одно значение. */
        if (scanf("%u", &n) == 1)
        {
            /* Вызов функции подсчета количества единиц и печать результата
               в стандартный поток */
            printf("Ones: %u\n", bitcount(n));
        }
        else
        {
            /* Если при вводе строки вместо ожидаемого беззнакового числа введена,
               например, строка, то scanf возвращает -1, что означает ошибку.
               При этом неверно введенные значения остаются в буфере чтения и
               повторный вызов scanf вновь приводит к ошибке.
               Для исключения повторных ошибок очищаем буфер ввода.
               Читаем посимвольно из буфера ввода, до тех пор пока
               не попадется символ '\r'.

               Обратите внемание, что в отличии от примеров lab1a, здесь
               ожидается символ '\r'. В качестве терминала последовательного
               COM порта рекомендуется использовать PuTTY. Программа PuTTY
               при нажатии клавиши Enter отправляет символ '\r', в отличии
               от командной строки ОС Windows или Linux, где отправляется
               символ '\n'. Для того, чтобы в PuTTY отправить символ '\n'
               необходимо нажать комбинацию клавишь Ctrl - J. 
               Для удобства в примерах лабораторных работ для микроконтроллеров
               ожидается символ '\r' от клавиши Enter. */
            while(getchar() != '\r');
            printf("Incorrect input\n"); /* Сообщаем о некорректном вводе */
        }
    }
/*----------------------Ваше решение заканчивается здесь----------------------*/
}
